Demo: Hosting in Console App

When it comes to self-hosting services you can host your service in just about any. NET process as discussed earlier. For debugging purposes it's very handy to do it in console app. So I'm going to create a New Project, go to Windows Desktop, and pick a Console Application project. And we'll call this Zza. SelfHost. I'll click OK. And the first thing we're going to want to do is reference the service library that we're trying to host. We're also going to need those standard references of WCF in there. So I'll Add Reference, go to Assemblies, and search on System. ServiceModel. So we'll select that, and the other one is System. Runtime. Serialization, so I'll add that as well. Now for the configuration of this service, we basically need the exact same configuration that we had when we were running in the service library. So I can go over to my service library and grab both the connectionStrings, and the system. serviceModel section, copy those, and paste them into my SelfHost configuration. So I can save that, and now we can focus on what we need in this console to actually be hosting. The way you host a service in. NET code is to use the ServiceHost class. That lives in the ServiceModel namespace so I'll add a using statement for that. So we'll new that up, and the argument you're going to want to pass here is actually the second option in the listed IntelliSense there. It's the serviceType itself. So we're going to do typeof ZzaService. So this is the implementation class, not the service contract. We'll resolve that to its namespace, and once we have the host this line of code is where it's actually going to read in the configuration for that service. So it basically goes out to the config, it looks for a service element that's mapped to that service type, and reads in the configuration for that service. Next up we have to get it to start listening for incoming messages, and we do that by opening the host. So we just call Open here. Now this is a non-blocking call, it blocks just long enough to get up and listening, and then it will return. And in our case because of our configuration it's actually going to be listening on both HTTP, with the basicHttpBinding, and TCP, with the netTcpBinding. Now, once it starts listening it's going to return, and if we don't do anything else here in our console app, it's going to leave our main method and shut down. So we need to keep our host open, and I'll do that with a Console. WriteLine and ReadKey. So now our console will start up, it'll start listening for incoming service calls, and it'll just sit there dormant doing that as long as we don't hit a key. Now when we're ready to leave and the key gets hit, we want to shut down gracefully. And we do that by calling host. Close. When you call Close on a Service Host it's a graceful shutdown, and what I mean by that is you could have multiple requests in process, where the message has already come in from the client, the service is still processing that message and trying to produce a response, and you don't want to just terminate those calls in progress, but you want to stop accepting calls at the point where you call Close. So that's exactly what WCF does. It'll stop accepting new inbound calls, it will complete any calls in progress and get their response out the door, and then it will return from the Close method and allow you to shut down your environment, or do whatever else is appropriate at that point. Now it's important to note that both Open and Close could throw exceptions, and in fact, even the construction of the Service Host could throw exceptions if you've got config errors. So you're generally going to want to wrap all this in a try/catch, and log out whatever kind of error occurs. Now with this in place we can go ahead and set the SelfHost as StartUp Project. We would want to go into the project Properties, WCF Options of our Service Library, and turn off the self hosting, because it's going to try to start up and claim the same ports that our SelfHost is now trying to claim. Then we could go ahead and Start. And again, because it's a new process trying to open sockets, we'll get the firewall warning here, we'll allow access, and we can see we have no errors in the console and it doesn't die on us. So this is basically what I call the happy page of self hosting, as long as no errors get dumped out, and it's sitting there waiting for a request, we're good to go. How could we prove to ourself it's answering requests? Well, we could fire up a browser and go to http://localhost:2112. Remember, that's our base address where metadata is exposed. And you can see we get what I call a happy page here in that we get this default rendered out page that WCF can produce describing the service. And if we click on the link here, for the WSDL, that's the actual metadata describing our service. A whole bunch of gunk you shouldn't have to understand yourself, but that a computer can understand to code generate a client proxy. So just with that much code, we have a SelfHost all ready to go. And again it uses the same configuration we talked through before. 