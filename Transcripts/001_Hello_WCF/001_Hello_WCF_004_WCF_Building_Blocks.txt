WCF Building Blocks

Now let's talk quickly about the building blocks you're going to use to build out WCF services and their clients. First and foremost, you start with a service contract. This is the definition of what's exposed at the service boundary, and as its name implies, it's a contract between a client and a service for how they're going to communicate. It's defined in terms of a. NET interface at a code-level, and we'll see that once we get to demos. Part of defining a service contract is to define data contracts. Service contracts are collections of operations, or methods, in. NET terms, and methods take parameters and return values. Those input parameters and their return values can be complex types, and those are what are called data contracts. So they are a contract for the shape, or schema, of the data that's going to flow across the wire when service operations are invoked. The combination of a service contract and its data contracts defines what the service boundary looks like to a calling client. Next, we have the service itself. And the service is just a. NET class that implements that service contract interface and can contain the implementation details of the operations that are exposed. Now good-layered architecture does apply here so you shouldn't necessarily put all the gory details of the service operations in that one class. You should think in terms of breaking it out into a business layer and data layer that sit beneath it, but that depends on the complexity of what you're doing. Next, this code needs a place to live and run on the server-side, and that's what's called the service host. You have a couple options for hosting in. NET we'll be covering. You could host in any. NET process, that would include a console application, potentially a client app, like a WPF or a Windows Forms client, most often this means a Windows service if you're going to host in an executable. You also have the option of hosting in IIS, Internet Information Server, and we'll look at that in the hosting module as well. Next, you're going to have clients that want to come and connect to your service. In those clients you're going to have some kind of consuming code. Now this client could be a true client application, such as WPF or WinForms, possibly server-side code behind in an ASP. NET application, but it could be another service, and service-oriented applications, services, often talk to other services. So the consuming code could be just about anywhere, but in this course we'll focus on. NET consumers. To call to a WCF service you need what's called a proxy, this is a chunk of code that runs and lives in the client application process, exposes an interface that is the same interface as the service, and allows the consumer to make calls against the proxy in process, and that proxy will dispatch the calls across the service boundary to the service, and then the service call is dispatched down into the service implementation. Now you can think of those calls from the proxy to the service as messages that flow from the client to the service through communication pipe. That communication pipe wraps up all the plumbing details of how the messages get from point A to point B, including what communication protocols, such as TCCP or HTTP is used, what kind of security you're using, if you're using distributed transactions, reliable messaging, and some of the other more advanced aspects of WCF that we won't get into in this course. Now part of the design of WCF is to abstract all that away from the code that you write in your services, and in your clients. So that kind of information gets pulled out to configuration. Configuration exists on the client and server side, and you can think of it as defining all the aspects that define the nature of that communication pipe between the client and the service. So those are all the basic building blocks that you're going to work with in WCF. 