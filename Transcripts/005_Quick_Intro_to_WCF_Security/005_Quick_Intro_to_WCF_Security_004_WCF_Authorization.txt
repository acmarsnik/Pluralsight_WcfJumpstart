WCF Authorization

Once you've received credentials and validated them from a client, you now have an identity for the client that you can base authorization decisions on, basically deciding what that caller is allowed to access on the server-side. What WCF does to support this is it establishes a thread principle based on the IPrincipal interface, and that IPrincipal contains an IIdentity, an interface-based representation of the identity of the caller. You can access this anywhere in your code by accessing the Thread. CurrentPrincipal static property. Once you have access to that principal you can do role checks, authorization checks based on roles using the IsInRole method that's part of the IPrincipal interface. You pass it a role name and it'll give you back a Boolean telling you whether the current authenticated user is in that role. You can also do this declaratively with attributes using the PrincipalPermission attribute on a service method. This attribute takes a couple of arguments; one is a security action that you'll set to demand, and the other is a role. So you can declaratively say, I want the caller to be in a given role before dispatching the call into this method. If you're familiar with the concept of claims you can also use the ClaimsPrincipal to check if the caller has certain claims. Claims are basically a more fine-grained way to do authorization, that can correlate to the concept of a role, but it could correlate to something much more fine-grained, like whether the caller has read permission on a given property of a given object, in a given collection. Finally there's a custom hook in WCF where you can implement a derived class from something called a ServiceAuthorizationManager, and get that wired into your service, and then you can have imperative code that makes authorization decisions based on the identity of the caller. 