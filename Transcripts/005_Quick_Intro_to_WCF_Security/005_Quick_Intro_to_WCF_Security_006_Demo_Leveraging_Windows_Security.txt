Demo: Leveraging Windows Security

In this demo I want to get you familiar with the authentication that happens by default with common WCF bindings. As I discussed in the slides, most WCF bindings are secure by default, and they're secure based on Windows credentials. Now we can demonstrate that by going into our Service class here, into one of the methods that gets called immediately on startup of our client application, and drop into one of these methods and access the Thread principal. So we can go ahead and set a breakpoint here, and take a look at the Thread principal that comes into this method when it gets called by our client. So I'll start up the application, and we've hit our breakpoint in the service. Notice if I hover over this a WindowsPrincipal is the Thread. CurrentPrincipal. And if we expand that, every principal has an identity based on the IIdentity interface, and the identity shows us that the current Thread principal is my Brian account that I'm running under. I've been authenticated via NTLM because I'm in a workgroup configuration. If I was on a domain with a domain account, the authentication type would be Kerberos. And the IsAuthenticated flag is set to true. Now the fact is I'm debugging localhost here, so you could think that that's just the process identity of the server host, the self-hosted console application here, but it's not.. NET applications, by default, do not establish the process identity as the Thread principal. And we can prove that to ourselves by going to the SelfHost itself, let me stop debugging, we'll copy this same line of code, go over to the SelfHost Program, and pop it in here right before we start hosting. So now if we start up again, we can see this principal is a generic principal, and the identity is not authenticated and is empty. So that call coming in from the client that hits here and gives us a Windows principal is the client identity flowing into our service. As a result of that we can start making authorization decisions in here. Programmatically, I could do an authorization decision by using the IsInRole method of the principal. So you can see here I can just call IsInRole directly on the principal object itself, passing a known role. When you're using Windows authentication it's going to check against Windows Groups by default. So here I'm using a special moniker in. NET, BUILTIN means the predefined groups that are part of a Windows system such as users and administrators. You could also certainly have a domain group here as well that you check against. Through some additional configuration that I won't show in this course, you could go look against a database for those roles instead. The other we could do it is to put a PrincipalPermission attribute on the method itself. We tell it we want a SecurityAction of Demand, and then we can specify the role that we're checking for right here. So with that code in place I can go ahead and run, we'll run past that breakpoint, and we can see our data comes down just fine because I happen to be an administrator on my own machine here. So those are two of the ways that you can do authorization checks. If you get into claims-based authentication, another option is to use the ClaimsPrincipal class. The ClaimsPrincipal class has a Current property that lets you get to the current ClaimsPrincipal that will be the same Thread principal, because under the covers the Thread principal that's established even when it's a Windows principal, derives from ClaimsPrincipal. So here I can say HasClaim, and then pass claim type and a claim value that I'm looking for. Claims give you more fine-grained control where you can define specialized claims such as whether a given user has the right to read or edit a given data type. And as you can see there's two things to it. The value can be determined dynamically based on the current execution context. So that's just a quick awareness that all principals in. NET, since. NET 4. 5, are ClaimsPrincipals and you can do more fine-grained authorization with claims than you can with roles on their own. 