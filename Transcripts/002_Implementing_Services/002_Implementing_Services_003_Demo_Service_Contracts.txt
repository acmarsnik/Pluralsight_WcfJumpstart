Demo: Service Contracts

The first step in starting to build out communication with WCF is to define your service. And the first step of that process is to define the service contract. I wanted to create a New Project here, and we're going to go with the WCF Service Library to contain our service definitions and our service contracts. I'm going to name the project Zza. Services, and the solution ZzaApp. As discussed in the first module, the overall scenario we're going to be building out is a pizza ordering system. So I'll click OK here, and as shown in the first module, what you end up with is a Class Library project that has some extra facilities for WCF, and has this pre-built Service1 in it. We're going to delete that off right away because we're going to put our own service in here. And likewise it had configuration for that service, which is no longer valid, so we'll get rid of that. I'm also going to go to the Properties and turn off the self hosting that this WCF Service Library enables, and go to the Debug tab and comment out the command line argument that starts up the WcfTestClient. At this point, what we really have is a true Class Library. It's not going to be starting any WCF specific stuff; it's basically a Class Library with the additional two references of WCF. So you always need System. ServiceModel when you're doing WCF stuff, and you'll need System. Runtime. Serialization when you're doing anything to do with data contracts, which we'll get into in this demo. So you might be asking yourself, why use the WCF Service Library instead of a Class Library, well, because then you always have this option to go back in here and turn this self hosting back on, and re-enable this TestClient to get back to basically a standalone, smoke testing, hosting environment for your service that's independent of whatever complexities your real host might end up having. So now we need to define our Service Contract. So I'm going to go Add a New Item in the Code category, and grab just a. NET interface. We're going to call this IZzaService, and click Add. Now when it comes to visibility of services,. NET visibility still matters if you're going to make references to this library to host it, for example. So I'll need to make this public for the purposes of hosting, but that actually says nothing about its visibility as a service, and being able to call this externally as a WCF service. What drives that is an attribute, and that attribute is the ServiceContract attribute. The ServiceContract attribute is in the System. ServiceModel namespace, so I'll resolve that here and add the using statement. Now right off the bat, this highlights an important aspect of WCF programming, is that it's an attribute-centric programming model. The WCF Team chose a declarative approach where you add attributes to things to indicate how they're going to participate in WCF communications, as one of the primary programming paradigms. Now we need to expose some functionality on this interface, so I'm going to add a few methods here that represent the operations that we need to support on our service. So to support our pizza ordering scenario the operations that we need, or methods on our interface, are we need to be able to retrieve a list of products to present to the person taking the order, we need to retrieve a list of customers to pick from one of those customers to associate the order, and then client-side they're going to formulate and order and send it on down through a SubmitOrder call for processing and fulfillment. Now we're not quite done yet defining the service contract because like I mentioned for the. NET visibility of the type not effecting the services ability, and that being driven by the ServiceContract attribute, the same is true of our operations on our interface. While in. NET code, if you were using an object that implemented this interface, you would be able to call those methods by casting to this interface. Service's ability is driven, again, by attributes. So we actually need to add to each one of these an OperationContract attribute. If you don't add an OperationContract to your methods, they won't be exposed as service operations to callers. Now obviously if we're going to be passing complex objects, like products, customers, and orders, we need definitions of those as objects, so we'll get to that next. 