Demo: Service Implementation

So far in the demos we defined our Service Contract, and we added in our Data Contracts in the form of entity definitions that are annotated with DataContract and DataMember. Now let's implement a service. A service is nothing more than a class that implements that interface, so we'll call this ZzaService. As mentioned for the interface,. NET visibility doesn't affect the service visibility, but it does affect where you can use this type, and we're going to need to host this somewhere, so I'm going to make it public. Then we implement the interface, and I can stub it out using Visual Studio. Now we just need to implement the details of these methods, so I'm going to pop that code in here quickly. So you can see we're going to use our EntityFramework DbContext to do our data access, we're going to retrieve products and customers and return them as lists, and down below we're going to take our order that comes in, add it to the Orders collection of the context, loop through each one of the order items associated with that order, and add it as well, and then save our changes off to the database. Now I've got some red squigglies here because I'm using Entity Framework for the first time now directly in our Services library. So I need to go and Manage NuGet Packages and install EntityFramework into that Service Library as well. And that resolves our red squigglies. Now there's a few other things we might want to do to make this a properly behaving service. First off, a DbContext maintains a connection under the covers, and it's disposable. So we want to add IDisposable to our service. We'll stub that out with Visual Studio, and what do we want to do in Dispose? We want to dispose our DbContext. Now you might be asking who's going to call Dispose? Well, WCF will do that for us. If it's hosting a service that it sees is disposable, each time it creates an instance of that service, and it knows it's done with it, it will check whether it implements IDisposable, and it will call dispose on it if so. That gets us into the instancing lifetime of WCF services. There's several different modes supported. The default one is that for a given client proxy, it's going to keep the service alive as long as that proxy's still communicating with the server side. So it's a sessionful kind of interaction. A slightly better default from a safety and scalability perspective is to be a per call service, which say that you'll get a new instance of your service created each time a call comes in to one of the operations. This is more how ASP. NET works in that it creates a whole new page and all the subsidiary objects each time a request comes in, because especially in a distributed application across a service boundary, the client can go away entirely or could take long periods of time between the calls to the service and you don't want to be holding on to objects and memory on a per-client basis if you care about scalability. So the way to drive that is another attribute. Up here at the top we can add a ServiceBehavior attribute, and we'll resolve that into the ServiceModel namespace, and ServiceBehavior has a number of properties we can set. The one we care about here is called InstanceContextMode. We're going to set that equal to InstanceContextMode. PerCall. So you can see your three options are PerCall, PerSession, and Single, which is short for Singleton. PerSession is the default, again it will keep this object alive and affiliate it with a single client proxy. Singleton means there will only be one instance shared across all callers. And PerCall is the one we really want here, and the one I suggest you use as your default on any service unless you convince yourself otherwise because it's the safest and most scalable, it will clean up the object from memory as soon as a service call is complete. So with PerCall, basically a message will come in bound for this GetProducts method, it will create an instance of the ZzaService, it will dispatch the call, and as soon as the method completes, if the object implements IDisposable it will call that, and then it will release references to that object, making it eligible for garbage collection. One other change we might want to make, just to highlight another feature of WCF, is that notice we're going and making multiple calls to the database effectively here. We push the Order and multiple OrderItems into the DbContext, and then we call SaveChanges. And Entity Framework does not actually send that as a single request to the database, it will make multiple calls, and there's multiple queries inserting those different objects. So we want to make sure those all get inserted with integrity, and the way to do that is transactions. Now we could use the System. Transactions namespace to define how we go about doing that, but part of the WCF programming model is to support transactions. And you can even support transactions flowing across the wire, which we won't get into in this course. But what I could do here is add an OperationBehavior, notice the symmetry here of ServiceBehavior at the class level, OperationBehavior at the method level, and back over on our ServiceContract, ServiceContract at the type level and OperationContract at the method level. So on our OperationBehavior we can set properties, and the one we want here is one called TransactionScopeRequired. Simply by putting that attribute on our method, it says that as you enter this method a transaction will be started, if you leave the method normally that transaction will be committed, and if you leave abnormally, meaning with an exception, then it will roll back the transaction for you. So a nice declarative programming model for transactions. With that in place our service definition is complete, and now we just need somewhere to run it, and that's what we'll get into in the next module. 