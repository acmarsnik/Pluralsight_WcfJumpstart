Service Implementation Overview

To implement a service with WCF, it's a multi-step process; the first thing you need is a place for the code to live. And as I showed in the first module, a good way to do that is to use a WCF Service Library. This is basically a class library project with a couple of extra WCF options to start up an automatic WCF service host, and optionally a WCF service client to test out your service within that class library. You don't have to use a WCF service library; you could just use a normal class library, or even embed them directly in the hosting project, but generally I recommend using the WCF Service Library as the most flexible option for containing your service definitions. The first thing you're going to put in that Service Library is a Service Contract definition. This is a. NET interface that's annotated with some attributes, the Service Contract attribute, and the operation contract attributes on the methods. This really defines what does the service boundary look like to call in clients? So it defines the operations that are exposed for remote invocation by a client. Now again, this service contract could be factored out to its own separate Class Library, and even, potentially, shared with the client-side, especially if you're going to hand-write your client-side proxies, which we'll touch on in a later module. But for this course I'm going to put the Service Contract definition directly in the Service Library. As part of defining the operations that are on that service contract, you have to define parameters to those methods, and return types. And those will often be complex types that you define as. NET classes with properties. It's only the properties that matter, in terms of what goes across the wire. So your Data Contracts are just classes that expose properties that are the types that are used as the parameters on your Service Contract operations and the return types. Those Data Contract classes could potentially have other logic in them, but usually you'll want to keep them to just simple entities, objects with properties that contain data, because that's what's actually going to go across the wire. Once you have your Service Contract definition, now it's time to get down to what's actually going to happen when a service operation is invoked, and that happens in your service implementation class. So this is just a. NET class that implements the interface that defines the service contract and has whatever logic you want to put in the methods that get invoked. Now, as mentioned in the first module, you could put all the gory details, thousands of lines of code in those service methods, in the service implementation class, that would be a bad design. You still want to think about a good layered architecture sitting behind the service boundary. So usually the service methods in the implementation class will just dispatch calls into business layer classes that then call data layer classes, and so on. In the code I'll be showing for this course things are not that complicated, but I do at least have a data layer separation so I call into my data layer from my service layer. But a real world complex service that has lots of logic and stuff behind it would probably have a business layer it would call into that would then call to a data layer. So those are the steps, let's get right down to defining those things in code. 