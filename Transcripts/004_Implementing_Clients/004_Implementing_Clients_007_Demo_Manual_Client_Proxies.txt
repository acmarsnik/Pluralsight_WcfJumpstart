Demo: Manual Client Proxies

So far I've only been talking about using code generated proxies, the add service reference functionality of Visual Studio. Sometimes developers new to WCF get a little mystified by all the magic that's happening in the code generation process, so I'd like to emphasize that you're not really bound to that. It's not that hard to write your own proxy class and dispatch the calls through it. So let's go ahead and do that real quick. I'm going to go into the Client project, and I'll Add a new Class, I'll call that class ZzaProxy, and click Add. Now the things that distinguish a proxy from a normal class are two things, one is it has a base class of ClientBase of T from the ServiceModel library, where T is your Service contract. Now I'm going to cheat a little bit here and use the version of the Service contract that was code generated for me on the client-side. If you are writing your proxies from scratch, that service contract won't be available, so you have two choices, one is add a reference to wherever your server-side service contract is defined and use it, but then you won't have the asynchronous methods you might want for a client application. The other option is to simply hand code that Service contract for the client-side as well. But for times' sake here I'm just going to use the one that was already code generated for me. So first off we have a base class of ClientBase of T, and again let me resolve that to the system ServiceModel namespace, and then we also implement the same ServiceContract. So let me stub that out with Visual Studio, and I'll clean up some namespaces here with CodeRush, and now we have these six methods that we have to implement. And then you might think, oh gosh, I've got a whole lot of work to do there, but the implementation of each of these, as you saw in the code generated, it's basically just going to delegate to the BaseClass's channel and call the same methods with the same parameters and return types. So I can just stub that out real quickly. And now you can see each one of these is just return Channel. whatever the method name is, and if it has parameters we pass those parameters to that method. The final thing you'll want to do in a hand-coded proxy is add the appropriate constructors. There's three constructors you're generally going to want on your proxy. One is the default constructor, which again we'll go look in the client-side configuration file for a single endpoint that's mapped to this Service contract. The second one is the one we've actually been using so far on the code generated proxies, it's the one where you can pass in the endpoint name and it will go look for that specific endpoint in the configuration. The third one, we haven't shown, is one that takes a binding and an address, and we delegate that down to a BaseClass that takes in the binding, and the BaseClass one actually requires a data structure called an EndpointAddress that just wraps that string-based address. So this allows us to programmatically create our proxies without any configuration at all. So with that proxy definition in place we could drop back over to our ViewModel and replace the call to construct the proxy with our manually created proxy. Nothing else about the code has to change because that hand coded proxy is fully equivalent with the code generated one, and I can run real quick to prove that. Now let me just close by saying, why would you hand code your proxies? Well, as soon as you write this code yourself, now you're fully in control of it. There are certain patterns that will emerge as you go and use your proxies over and over again, you might encapsulate something like setting credentials on the proxy into the proxy itself so that you don't have to do it each time you new one up, or you could be leveraging one of the extensibility points of WCF that lets you do additional things on the client-side. That's a subject for a more advanced course, but if you were doing those kinds of things you could encapsulate that extension code into your proxy class. For most simple scenarios, just expose metadata and code generate your proxies with add service reference. 