Demo: Completing the Client Service Calls

So to finish off our calling code here from our Client to our Service, there's a few more things we need to do. Obviously we've got to fill out the SubmitOrder method, but we're not quite done yet on the loading process. Anytime you make a service call, this is one of the riskiest thins you can do in terms of potentially throwing exceptions. Think of all the things that could go wrong here, the service could not be running, your address could be incorrect, you might not be authorized to access that service, the service itself may have bugs such as configuration bugs like an incorrect connection string, so there's a whole lot of things that go wrong there. So you definitely want to be wrapping your service calls in try/catch handling because you know right there that you're dispatching a call across a service boundary where lots of things could go wrong, and you can isolate what you want to do next if that service call fails at the place where you know it's based on the service call. So I'm going to add here a try/catch block around this code, and I'll just pop a message box if something goes wrong for simplicity for now. Now the other thing to realize about the structure of this code is we want to make sure we release the resources that our proxy has underneath it, even if we have an exception. So I can move my proxy construction outside the try/catch, and then I'll move my proxy. Close into a finally block. Now you're in a much safer place in terms of making your service call. Finally, let's flush out the SubmitOrder method, I'm going to pop some code in there and explain what we got here. Basically, I'm going to check that the CurrentOrder customer has been set, that drop-down box in the UI, and that one or more OrderItems have been added to our order. Then I'm going to set up my proxy again, I'm going to call SubmitOrder with the CurrentOrder, and then I'm just going to reinitialize everything to an empty order basically. So same basic structuring we had before. The one other thing to point out here that I didn't before is if we go look at the SubmitOrder service method, the definition of that is based on an order. The DataContract for an order we looked at briefly before, but I didn't highlight this aspect, that DataContracts can contain other DataContracts. So an order contains a collection of OrderItems, and the OrderItem itself is a DataContract. And that potentially could contain, say, an entire product object. So you can have a whole object graph that gets passed as a parameter, or gets returned as a return value from a service operation. And WCF will take care of serializing that entire object graph, and it can even handle circular references with some additional annotations on the DataMembers. So now with that code in place our client-side application is pretty much complete. I can start things up again, we can wait for the data to load, we can add some items to our order, we can select a customer, and then we can submit our order. And functionally we're to the place we were when I demonstrated the end to end app in module one. Now there's one more thing I want to show in the next demo, and that is manually creating your own proxies, because there are certain times that might make sense to do. 