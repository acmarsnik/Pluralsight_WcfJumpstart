Demo: Calling Service Methods

Now we're ready to start writing some code that actually makes calls to our service from our client application. I'm going to drop into this MainWindowViewModel and paste in some code. Now basically the code I pasted in here, you don't have to understand to get what you need out of this course, but it's a bunch of UI coordination logic to expose our products and our customers for data binding purposes to allow us to add OrderItems to an order that is our current order, and eventually get to the point where we are actually making service calls. So we do have to load our products and customers for presentation purposes as a first step, and then after we allow the user to formulate an order through the UI, we need to submit that order back to the backend. So we need to start filling in our service calls here in these two methods. So to start making our calls I'm going to create an instance of the ZzaServiceClient. That was the name of the proxy class that was code generated for us in this namespace. We'll call that our proxy, and we'll just new it up with the default constructor. Then we can dispatch a couple of calls, synchronous calls in this case, through GetProducts and GetCustomers. These are going to be blocking calls, blocking the UI thread until that service call completes. Now that's not necessarily the best thing to do from a user experience perspective, and that's why they also code generate the task-based async methods. So we could instead put the async suffix on this, put an await keyword in front of it, and make this an async method. And we could do the same for the GetCustomers. Now it'll get to the point of dispatching this call, free up the UI thread until the results come back, grab the UI thread back, and put it into our products collection, then dispatch another async call, free up the UI thread, and then get it back when the results are ready to put into customers. A much better way to go there. Now a proxy holds a connection under the covers, and is a disposable object, so you'll want to take your proxy and close it when you're done making your calls with it. So with that minimal code in place, we should be able to go and set our StartUp Projects to start both the SelfHost and the Client. You can do that in Visual Studio with Set StartUp Projects, Multiple startup projects, SelfHost, Start, and Client, Start. And we want to order these so that the SelfHost is listed before the Client since it's going to make a call immediately on startup. Click OK. Now we'll go ahead and run, and we can see it throw in an exception. And if you read the error message there, it's basically complaining because it's finding more than one endpoint configuration. What it's talking about there is when we did our code generation it added this client- side configuration for WCF, and you can see it's a client section instead of services with our two endpoint definitions on them, and it generated that based on the metadata. If you use the default constructor of a proxy, there can only be one endpoint for the Service contract that that proxy is based on, and here we have two. So we need to give it the name of the particular endpoint we want it to use. And I'll grab the TcpBinding's name. We'll come back here into our ViewModel and pass that name to the constructor of the proxy, thus instructing it to use this specific endpoint configuration to call that service. With that in place I can go ahead and run, we see our Service startup, then our Client, and asynchronously the data pops into the UI there, and our customers are listed up above here. So our service call is succeeding. 