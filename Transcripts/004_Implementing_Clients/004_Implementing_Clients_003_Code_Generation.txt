Code Generation

Now when it comes to proxy code generation, as you've seen, it starts with an Add Service Reference in Visual Studio. That's going to bring up a dialog that lets you enter a service address and press a Go button, or if the services are auto-hosted in the same solution, through a WCF Service Library or through a web application project, then you can just press the Discover button. Another important thing in that dialog is to enter the code generation child namespace that the code will be generated into. There's also an Advanced button that will take you to a configuration dialog that lets you configure several things. One is whether you want async methods, and if so, based on what async pattern? The current dialog supports doing it either based on the task-based async pattern, which is the default, or you can use a more old style pattern, which does begin and end methods, and an async method coupled with a competed event. It also has options for what kinds of collection and dictionaries will be generated when the service contract parameters or return types include those. By default, at the service boundary WCF denormalizes everything into an array, but in the code generation process, and the deserialization or serialization of those parameters, it can turn those into any collection type. And for dictionary type things, key value pairs, it can use various types of dictionary available in. NET. Another important option in there is whether to use referenced assemblies in the code generation process. What that specifically means is for data contracts, if it finds the necessary type in a referenced assembly it won't go generate it, and we'll see that in action in the demos. Once you've done your code generation what Visual Studio generates is the client-side compatible service contract. I say compatible here because you'll see in the demos it's not the exact same service contract that is defined on the server-side. The server-side only has the synchronous methods defined, if you have an async option checked, which there is by default, then it's also going to generate async method signatures on the client-side. It also has some extra attributes and namespaces and things that may not be defined on the server-side, but it's defined in a way that's fully compatible with the service contract. Probably most importantly, it's going to generate the client proxy class that you're going to use to dispatch your calls from your consuming code. Part of defining the client-side service contract and the proxy class, is to define data contracts for the parameters and return types, if they're not already present in your referenced assemblies. And finally, just like the server-side needs configuration, the client side needs configuration as well. So the client endpoint configuration that's compatible with the service that you're trying to consume will be code generated for you. Now that client configuration may not be everything that you need. Some aspects of the configuration, things like time outs and max message sizes and things like that, you may have different requirements on the client and server-sides. So those don't get code generated by default and you may need to enter what is appropriate for the client on the client-side. So with that let's get into some demos of generating your client side proxies, making calls, and even manually creating your proxies. 