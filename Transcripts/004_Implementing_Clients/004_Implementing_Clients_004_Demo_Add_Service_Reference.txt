Demo: Add Service Reference

In this demo we're going to start diving into implementing a WCF client able to call our ZzaServices for our pizza ordering scenario. Starting point for this one is basically the same solution that we had in the previous demos in the last module with one additional project, which is a WPF application project. I've already defined some XAML in the MainWindow for laying out the basic UI that you saw in the first module demo, and the structure of this app happens to be using the MVVM pattern, but for this course it's not really important that you know anything about WPF or MVVM to understand what's going on, we're just going to focus on how you enable the client to make calls and how you make those calls, regardless of what kind of. NET client it is. So as you saw in the first module, the easy way to get started is to use the add service reference capabilities of Visual Studio to code generate a client-side proxy. And for that to work that service is going to have to be up and running to expose the metadata that the code generation is based on. If you just run it in Debug then Visual Studio's not going to let us modify any projects in the solution. So I'm going to start debugging on that SelfHost with CTRL + F5 to start it outside the debugger. Now it's up and running with the metadata exposed, and we can go to our client, right-click, say Add, Service Reference. And in this case, Discover won't work for us as we used in the first module because we're not trying to discover those auto hosted things in our solution, we're trying to get the metadata from our running service. And if you remember from previous modules, that metadata was exposed on http://localhost:2112. So I can type in that address and click Go. It goes and reads down the metadata from that service. You can see it shows up there, tells you what's exposed at that service, and down at the bottom here is a namespace. I'm going to change this to ZzaServices, basically that's going to be a child namespace of the project namespace where the code generation is going to happen. Now when you do this you can go to the Advanced button here and there's a bunch of options here. Notice at the top, it's going to generate task-based asynchronous operations for our service methods. It'll actually always generate synchronous ones, blocking calls that you can make, but it'll also generate asynchronous ones here, by default. And they're based on the new task-based async pattern that allows us to do the async/await keywords in C#. Down below it talks about the data types, and you can see any collection it's going to generate is going to be a System. Array by default. On the server side we were exposing List of T for products and customers, so we could choose List, but for data binding purposes in WPF, ObservableCollection is an even better option. So I'm going to pick that as my collection type I want generated. So it kind of shows that the server and client-side are decoupled a bit. Server-side said it was exposing List of T, but that's. NET specific type, at a wire level it's just a collection, it's an array. And that array can be morphed back into any collection type on the receiving side on the client. Notice this reuse types in referenced assemblies, this is going to come up in a bit when we talk about the data contracts being generated. So I can click OK here and then click OK out of the main dialogue, and now it's going to go through a code generation process. You see it pop out the references because it also added our ServiceModel and Runtime. Serialization references, and under Service References we now have this ZzaServices node. If we go to the top of Solution Explorer and say Show All Files, we'll see that under that node is actually a whole bunch of stuff, some metadata it read down, and the most important thing under here is the Reference. cs file. This is where the main code generation happened that you'll be consuming in your code. Now notice that it redefined Product, Customer, Order, and so on, all our model objects that were already defined in our entities library. This is so you can go and consume someone else's service where you may not even have those data contract definitions available to you, but client-side you're going to need some compatible object to read the data into. In addition to these entity types in here, further down in the file, there's a service contract definition. And notice the service contract looks a little different than it did on the server-side. If we go look at our server-side service contract definition, it was a whole lot simpler. The one that gets code generated here, first off, has fully qualified namespaces; it also has these Action and ReplyAction properties on the OperationContract. And then notice it's got a synchronous and an asynchronous version of each method as well. So that's the default code that gets generated for the client-side version of the service contract. It's fully compatible with the server-side one, but it's a different definition. And when you do add service reference you don't have any control over preventing that from getting generated. Additionally, it always defines this channel interface that you can generally ignore, and then most importantly, is the ZzaServiceClient class. This is the actual proxy class, the thing that you'll make calls through to get them dispatched to the server-side. A proxy class is distinguished by deriving from client base of T, where T is the service contract that this proxy is for. In addition to the generic being based on it, it implements that interface. So it exposes the same API client-side that is exposed on the server-side. So the client-side code can call methods on the proxy as if it was talking directly to the service itself, and the proxy will be responsible for dispatching those calls across the service boundary. The proxy class has a bunch of constructor options generated, and then down below are the actual methods such as GetProducts here, and you can see all it does is delegates to the base class's Channel to dispatch that call GetProducts. So that's the nature of the generated code, now say we didn't want these duplicate definitions of the entities. If we're writing the client and we're writing the service, there's no reason we have to have those two definitions for the entities. The way we can solve that is simply go up here to our client and Add a Reference to our entities library, where those data contracts are defined. We can go back to our Service Reference, right-click, and say Update Service Reference. At this point it's going to read back in the metadata from the service and recode generate the proxy code on the client-side. Once it's done that we can go back down in the Reference. cs, and we can see here that now all of those entity types are not duplicated here in the code generated code. We've just got the Service Contract definition, the Channel, and the proxy class itself. And it's just using the entity types that come out of our entities library, which is generally desirable if you're writing both the client and the service yourself, because now you have one entity definition, and you can be guaranteed that it's compatible on both sides of the communication. If you need to reconfigure anything about the service you can always go back to that service definition and say Configure Service Reference and you get back to the options dialog that was under the Advanced button when you were generating the proxy. And it's really because of this reuse types in referenced assemblies that our entities now are being used out of the entities library. 